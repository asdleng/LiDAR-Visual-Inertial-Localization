void divideGrayMatByScalar(cv::Mat& grayImage, double divisor);
void loadExposureTime();
double linearInterpolation(const std::vector<double>& xValues, const std::vector<double>& yValues, double targetX);
float calculateEdgeScore(const cv::Mat& img, int x, int y);
    exp_file_i.open("/home/weilin/vio_in_lidar_map/src/vio_in_lidar_map/Log/exp.txt",ios::in);
    res_file_i.open("/home/weilin/vio_in_lidar_map/src/vio_in_lidar_map/Log/response.txt",ios::in);
loadExposureTime();
float violm::calculateEdgeScore(const cv::Mat& img, int x, int y)
{
    // Calculate the gradient using the Sobel operator


    // Get the edge score at the specified location (x, y)
    float score = gradientMagnitude.at<float>(y, x);

    return score;
}
void violm::divideGrayMatByScalar(cv::Mat& grayImage, double divisor) {
    // 检查输入图像是否为空
    if (grayImage.empty()) {
        std::cerr << "输入图像为空" << std::endl;
        return;
    }
    debug_file<<"图像大小："<<grayImage.rows<<","<<grayImage.cols<<std::endl;
    // 循环遍历图像的每个像素
    for (int i = 0; i < grayImage.rows; ++i) {
        for (int j = 0; j < grayImage.cols; ++j) {
            // 获取当前像素的值并除以给定数值
            uchar& pixel = grayImage.at<uchar>(i, j);
            double p2 = linearInterpolation(response,index_response,pixel);
            
            p2 /= divisor;
            if(p2>255) p2 = 255;
            pixel = linearInterpolation(index_response,response,p2);
        }
    }
}
void violm::loadExposureTime(){
    std::string s;
    getline(res_file_i,s);
    std::stringstream ss(s);
    for(int i=0;i<256;i++){
        index_response.push_back(i);
        double res;
        ss>>res;
        response.push_back(res);
    }
    double time;
    std::vector<double> exp_10;
    std::vector<double> index_10;
    int index = 0;
    while(exp_file_i>>time){
        index_10.push_back(index);
        index+=10;
        exp_10.push_back(time);
    }
    for(int i=0;i<index;i++){
        double exp_t = linearInterpolation(index_10,exp_10,i);
        exp_time.push_back(exp_t);
    }
}
double violm::linearInterpolation(const std::vector<double>& xValues, const std::vector<double>& yValues, double targetX) {
    if (xValues.size() != yValues.size()) {
        std::cerr << "x坐标和y坐标数组长度不一致" << std::endl;
        return 0.0; // 错误处理，返回默认值
    }

    for (size_t i = 0; i < xValues.size() - 1; ++i) {
        if (xValues[i] <= targetX && targetX <= xValues[i + 1]) {
            double x0 = xValues[i];
            double x1 = xValues[i + 1];
            double y0 = yValues[i];
            double y1 = yValues[i + 1];
            return y0 + (targetX - x0) * (y1 - y0) / (x1 - x0);
        }
    }

    std::cerr << "目标x值不在给定范围内" << std::endl;
    return 0.0; // 错误处理，返回默认值
}
}   //namespace lvo
